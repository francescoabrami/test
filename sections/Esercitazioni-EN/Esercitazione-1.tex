\documentclass[../main.tex]{subfiles}

\graphicspath{{\subfix{../images/}}}

\newpage


\begin{document}

%% BEGIN WRITING %%

\section{Esercitazioni - ENS}

Affrontare ora tutte le esercitazioni della prima parte relativa alla teoria dei segnali (TS) andiamo ad affrontare le esercitazioni relative alla sezione di elaborazione numerica dei segnali (ENS). 

\subsection{Esercitazione 1 - 12/11/2025}

Iniziamo ora andando ad affrontare la prima esercitazione della seconda parte di corso in cui andremo a risolvere esercizi riguardo la rappresentazione dei segnali a tempo discreto e la loro energia e potenza.
In particolare ci saranno molto utili i grafici con cui rappresentare i segnali trattati. 

Ci sarà inoltre utile verificare, attraverso l'utilizzo di MATLAB, il corretto svolgimento degli esercizi tanto quanto la possibilità di effettuare elaborazioni su segnali a tempo discreto i quali non limitano il proprio supporto a pochi punti. 

Si ricorda che come al solito tutti i codici utilizzati saranno riportati all'interno di questa sezione.
\subsubsection{Esercizio 1 - Rappresentazione grafica dei segnali}

In questo primo esercizio dato il segnale a tempo discreto:

\[ x[n] = \begin{cases}
	0 \hspace{10pt} n < 0\\
	n \hspace{10pt} 0 \leq n \leq 10\\
	0 \hspace{10pt} n > 10
\end{cases} \]\

Si chiede di rappresentare graficamente i seguenti segnali:

\begin{enumerate}
	\item[\textbf{a)}] $y[n] = x[n+5]$
	\item[\textbf{b)}] $y[n] = x[-n+5]$
	\item[\textbf{c)}] $y[n] = x[2n]$
	\item[\textbf{d)}] $y[n] = x[n+10] + x[-n+10] - 10\delta[n]$
	\item[\textbf{e)}] Scomporre $x[n]$ nella somma di un segnale pari e uno dispari e rappresentare graficamente i due segnali.
\end{enumerate}

Cominciamo prima di tutto andando a rappresentare il segnale di partenza $x[n]$. Come possiamo vedere il segnale è nullo per valori negativi o maggiori di dieci. Possiamo dunque dedurre che il segnale abbia un supporto pari a 11, ottenuto contato il numero di valori per cui non è nullo ovvero tutti i punti tra zero e dieci includendo anche gli estremi.

Capito questo ci rimane molto semplice disegnare il segnale che sarà dato da una sequenza (questo il termine corretto per i segnali a tempo discreto) crescente di valori. In particolare in zero avrà valore nullo, in uno varrà uno, in due due e così via fino ad arrivare a dieci.

Riportiamo di seguito il grafico del segnale ottenuto in MATLAB:

% TODO GRAFIO ENS 1

Come al solito segue anche il codice utilizzato per la generazione del grafico appena visto:

\lstinputlisting[language=Matlab, firstline = 6, lastline = 13]{code/ENS-1.m}


Capito come è fatto il segnale di partenza $x[n]$ possiamo ora analizzare il caso \textbf{a} che altro non è che una traslazione della nostra sequenza verso sinistra di fatto anticipandola.
Al fine di evitare confusione per capire se una sequenza viene anticipata o ritardata, dunque traslata verso destra o sinistra, possiamo ragionare nel seguente modo. In questo caso prendiamo la scrittura del nostro nuovo segnale:

\[ y[n] = x[n+5] \]

Andiamo a sostituire un valore di $n$, per esempio lo zero, ed otteniamo che:

\[ y[0] = x[0+5] = x[5] \]

Ovvero che il segnale traslato in zero, $y[0]$ dovrà valere quanto vale il segnale originale, $x[5]$ in cinque.
Anche senza andare a calcolare un secondo punto possiamo vedere come il nostro segnale si sia "spostato indietro" ottenendo di fatto il segnale riportato di seguito:

% TODO SEGNALE y+5

Il codice ottenuto per generare il grafico è il seguente:

\lstinputlisting[language=Matlab, firstline = 17, lastline = 28]{code/ENS-1.m}

Passiamo ora al punto \textbf{b} dove abbiamo lo stesso segnale di partenza che viene anticipato di cinque campioni effettuando però un rilbaltamento della sequenza in quanto la variabile $n$ appare con il segno negativo.
Di fatto per ottenere il grafico richiesto in questo punto possiamo andare a prendere il grafico già traslato del punto \textbf{a} e ribaltarlo ottenedo il risultato seguente:

% TODO GRAFICO y-5

Come di consueto segue anche il codice MATLAB per generare il grafico:

\lstinputlisting[language=Matlab, firstline = 32, lastline = 43]{code/ENS-1.m}

Come possiamo notare il codice utilizzato è identico a quello precedente ma con una sola differenza ovvero quella di aver cambiato il segno della variabile $k$ nella seconda parte della quinta riga.\\


Passando oltre raggiungiamo ora il caso \textbf{c} in cui possiamo notare come sia stata effettuata un'operazione di sottocampionamento. In altri termini, allo scorrere di $n$, stiamo solo selezionando i valori dei campioni pari del segnale di partenza $x[n]$. Dovessimo costruire il segnale $y[n]$ pezzo per pezzo possiamo fare come fatto in precedenza ed andare a sostituire:

\[y[n] = x[2n] \rightarrow y[0] = x[2 \cdot 0] = x[0] \]
\[y[n] = x[2n] \rightarrow y[1] = x[2 \cdot 1] = x[2] \]
\[ \dots \]
\[y[n] = x[2n] \rightarrow y[5] = x[2 \cdot 5] = x[10] \]

Come possiamo vedere il supporto della sequenza risultante sarà dimezzato in quanto abbiamo sottocampionato la sequenza di partenza prendendo solo alcuni campioni.
In particolare otteniamo in grafico seguente:

% TODO GRFICO

Come di consueto segue anche il codice MATLAB usato per generare il grafico:

\lstinputlisting[language=Matlab, firstline = 47, lastline = 58]{code/ENS-1.m}

Proseguiamo ancora ad affrontiamo ora il punto \textbf{d} dove il nostro segnale è ora composto da tre parti distinte e sommate tra di loro.
Come possiamo subito vedere, ricordando i casi \textbf{a} e \textbf{b}, le prime due componenti corrispondono rispettivamente ad una traslazione di dieci campioni del segnale $x[n]$ verso sinistra ed a un successivo ribaltamento.

Di seguito sono riportati, in pannelli separati, i grafici delle prime due sequenze:

% GRAFICI SEQUENZE

Il codice utilizzato per ottenere i grafici appena visti è idenico a quello visto nei casi \textbf{a} e \textbf{b} dove invece di traslare di un numero di campioni pari a cinque di trasla di dieci.
Ora che abbiamo visto come sono composte le prime due sequenze andiamo ad analizzare la terza. La terza sequenza non è altro che una delta, centrata in zero, moltiplicata per una costante pari a dieci con l'effetto di amplificarla in ampiezza.

Compresa anche questa ultima parte possiamo andare a mettere tutto assieme ottenendo il seguente grafico:

% GRAFICO TUTTO UNITO

Come al solito segue anche il codice MATLAB utilizzato:

\lstinputlisting[language=Matlab, firstline = 62, lastline = 85]{code/ENS-1.m}

Volendo essere precisi notiamo che nell'origine le tre sequenze si sovrappongono, andiamo dunque a semplificare una delle due delta positive con quella negativa (è sottratta) ed otteniamo il seguente risultato:

% GRAFICO FINITO

Per ottenere tale risultato in MATLAB si è omessa la scrittura della delta e si è rimosso un campione di una delle due sequenze positive.

Concludiamo ora l'esercizio andando ad analizzare il punto \textbf{e}.
Per riuscire a scomporre il segnale $x[n]$ in due segnali, uno pari e l'altro dispari, dobbiamo operare nel seguente modo.
Prima di tutto i due segnali che indicheremo come $x_p[x]$ e $x_d[x]$ dovranno essere ottenuti tramite una qualche trasformazione di $x[n]$ moltiplicata per $\tfrac{1}{2}$ in quanto entrambi dovranno contribuire per metà alla creazione del segnale.
In particolare possiamo ottenere il segnale pari andando a ribaltare $x[n]$ ottenendo:

\[x_p[n] = \frac{1}{2}\big(x[n] + x[-n]\big)\]\

Dato che per ora il segnale ottenuto non è nullo prima dello zero ed è solo pari alla metà dall'ampiezza desiderata dobbiamo andare a sommare ancora un pezzo di sequenza alla parte positiva togliendo la sequenza negativa per ottenere il segnale $x[n]$, si ottiene che:

\[x_d[n] = \frac{1}{2}\big( x[n] - x[-n] \big) \]\

Seguono i grafici dei due segnali appena descritti:

% TODO GRAFICI SEGNALI +-

Infine come nostro solito riportiamo il codice MATLAB utilizzato per generare i grafici riportati sopra

% TODO CODICE MATLAB SEGNALI +-


\subsubsection{Esercizio 2 - Convoluzione di segnali a tempo discreto}

Si considerino le seguenti sequenze e si calcoli la convoluzione lineare discreta:

\begin{enumerate}
	\item[\textbf{-}] $ x_1[n] = \delta[n] + 2\delta[n-1] + \delta[n-2] $
	\item[\textbf{-}] $ x_2[n] = 3\delta[n] + 2\delta[n-1] + \delta[n-2] $
\end{enumerate}

Verificare il risultato ottenuto attraverso un codice MATLAB utilizzando la
funzione \texttt{conv(a,b)} implementata all'interno dell'ambiente di sviluppo.\\


Prima di cominciare con i calcoli andiamo a rappresentare graficamente queste due sequenze. Come possibile intuire si ottengono i seguenti grafici:

% TODO GRAFICI CONV

Segue anche il codice MATLAB utilizzato per crearli.

Adesso che abbiamo i due operandi possiamo andare a scrivere l'operazione di convoluzione seguendo la definizione, si ottiene che:

\[ z[n] = x_1[n] \ast x_2[n] = \sum_{k = -\infty}^{+\infty} x_1[k] \cdot x_2[n - k] \]\

Come possiamo vedere la convoluzione tra queste due sequenze risulta essere il prodotto tra la prima sequenza $x_1[n]$ e la seconda ribaltata e traslata ovvero $x_2[n - k]$.
Adesso possiamo procedere in due modi diversi: facendo il prodotto attraverso operazioni grafiche oppure attraverso il calcolo vettoriale.

Per semplicità svolgeremo il calcolo con la notazione vettoriale e riporteremo solo uno schema dello svolgimento grafico. Ricordiamo che l'algoritmo che viene eseguito è lo stesso e che non cambia assolutamente nulla tra un metodo e l'altro. In particolare il metodo vettoriale risulta più comodo e veloce ma forse meno intuitivo.

Prima di tutto andiamo a scrivere i nostri vettori di partenza. Come sappiamo, dovendo far scorrere un vettore lungo l'altro, abbiamo bisogno di inserire degli zeri ai lati dei nostri vettori che facciamo scorrere per evitare che siano troppo corti. Nel nostro caso essendo entrambi i vettori di lunghezza tre, e volendo rappresentare come primo ed ultimo scenario il caso in cui si ha una sola sovrapposizione, dobbiamo andare ad aggiungere, ad ogni lato, un numero pari di zeri alla lunghezza del vettore più corto togliendo uno. Il secondo vettori si ottiene aggiungendo un numero di zeri opportuno. Ricordiamo che questo ragionamento vale quando a scorrere è il vettore di lunghezza minore.
Fatti i passaggi appena elencati otteniamo dunque che:


\begin{center}
$x_1[n] = $
$\begin{pmatrix}
	0&0&1&2&1&0&0
\end{pmatrix}$	\\
$x_2[n] = $
$\begin{pmatrix}
	1&2&3&0&0&0&0
\end{pmatrix}$	
\end{center}

Adesso non ci basta altro che moltiplicare i due vettori e sommare le singole componenti.
Seguono ora tutti i casi andando ad esplicitare la definizione di convoluzione sottolineando i numeri che si sovrappongono. Ricordando che il prodotto per zero è nullo i valori che si sovrappongono con degli zeri vengono ignorati.

\begin{center}
$\hspace{19pt} x_1[k] = $ 
$\begin{pmatrix}
	0&0&1&2&1&0&0
\end{pmatrix}$	
\end{center}

\begin{center}
$x_2[0-k] = $
$\begin{pmatrix}
	1&2&\underline{3}&0&0&0&0
\end{pmatrix}$	\\
$x_2[1-k] = $
$\begin{pmatrix}
	0&1&\underline{2}&\underline{3}&0&0&0
\end{pmatrix}$	\\
$x_2[2-k] = $
$\begin{pmatrix}
	0&0&\underline{1}&\underline{2}&\underline{3}&0&0
\end{pmatrix}$	\\
$x_2[3-k] = $
$\begin{pmatrix}
	0&0&0&\underline{1}&\underline{2}&3&0
\end{pmatrix}$	\\
$x_2[4-k] = $
$\begin{pmatrix}
	0&0&0&0&\underline{1}&2&3
\end{pmatrix}$	

\end{center}

Andiamo ora a fare le moltiplicazioni tra i termini in sovrapposizione:

\begin{center}
	$z[0] = \sum_k^{\infty} = x_1[k] \cdot x_2[0-k] =  3 \cdot 1 = 3$\\
	$z[1] = \sum_k^{\infty} = x_1[k] \cdot x_2[1-k] =  2 \cdot 1 + 3 \cdot 2 = 8$\\
	$z[2] = \sum_k^{\infty} = x_1[k] \cdot x_2[2-k] =  1 \cdot 1 + 2 \cdot 2 + 3 \cdot 1 = 8$\\
	$z[3] = \sum_k^{\infty} = x_1[k] \cdot x_2[3-k] =  1 \cdot 2 + 2 \cdot 1 = 4$\\
	$z[4] = \sum_k^{\infty} = x_1[k] \cdot x_2[4-k] =  1 \cdot 1 = 1$
	
\end{center}

Ottenuti ora i valori del vettore $z[n]$ abbiamo che:
\[ z[n] = \begin{pmatrix}
	3&8&8&4&1
\end{pmatrix} \]

Possiamo anche riscrivere la sequenza ottenuta così:

\[ z[n] = x_1[n] \ast x_2[n] = 3\delta[n] + 8\delta[n-1] + 8\delta[n-2] + 4\delta[n-3] + \delta[n-4] \]\

Verifichiamo ora il risultato ottenuto attraverso MATLAB.
Per verificare il risultato andiamo ad utilizzare il seguente codice:

% TOTO CODICE CONV.

Il risultato che otteniamo è identico a quello calcolato in precedenza il che conferma l'esattezza del calcolo.
Infine possiamo andare ad eseguire un plot della sequenza $z[n]$ ottenendo il seguente risultato:


% TODO CODE MATLAB E.2

Infine riportiamo uno schema che riassume quanto appena fatto ma operando graficamente:

% TODO METODO GRAFICO


\subsubsection{Esercizio 3 - Determinazione e calcolo di potenza ed energia finite}

Passiamo ora all'esercizio successivo dove ci è chiesto di determinare se le seguenti sequenze sono a energia finita o a potenza finita e calcolarne energia e potenza. 

\begin{enumerate}
	\item [\textbf{a)}]  $ x[n] = \begin{cases} e^{-n} \hspace{10pt} n \geq 0 \\ 0 \hspace{22pt} n < 0 \end{cases}$
	\item [\textbf{b)}] $x[n] = A$
	\item [\textbf{c)}] $x[n] = Ae^{-j2\pi \tfrac{n}{N}}$
	\item [\textbf{d)}] $ x[n] = \begin{cases} A\hspace{10pt} n \geq 0 \\ 0 \hspace{12pt} n < 0 \end{cases}$
	\item [\textbf{e)}] $ x[n] = \begin{cases} A \hspace{10pt} n \geq 0 \\ 0 \hspace{22pt} n < 0 \end{cases}$




\end{enumerate}

\subsubsection{Esercizio 4 - Sistema di riconoscimento vocale}
\subsubsection{Esercizio 5 - Periodo di un segnale a tempo discreto}

















\end{document}